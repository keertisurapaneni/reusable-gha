name: "Build and Deploy CI"

on:
  workflow_call:
    inputs:
      aws_account:
        description: "AWS account number"
        required: true
        type: string
      environment:
        description: "Environment to deploy to"
        required: true
        type: string
      cluster:
        description: "Name of cluster to deploy to if you would like a deploy to happen (defaults to only cluster in account if there is just one)"
        required: false
        type: string
      install_node:
        description: "If true, installs node"
        default: false
        required: false
        type: boolean
      node_version:
        description: "Version of node to install (required if install_node provided)"
        default: "16.x"
        required: false
        type: string
      aws_region:
        description: "AWS region of cluster"
        default: "us-east-1"
        required: false
        type: string  
      aws_parameters:
        description: "AWS Parameter Store to Environment Variables"
        required: false
        type: string
      install_ruby:
        description: "If true, installs ruby"
        required: false
        type: boolean
      service:
        description: "Name of the service being deployed"
        default: ${{ github.repository }}
        required: false
        type: string
      test_command:
        description: "Command that triggers any tests against built image"
        required: false
        type: string
      build_args:
        description: "Comma delimited list of build args" ## EXAMPLE: 'WEBAPP_FILE=devint, RAILS_ENV=production'
        required: false
        type: string
      dockerfile_path:
        description: "Path to Dockerfile"
        default: Dockerfile
        required: false
        type: string
      deploy:
        description: "If true, pushes to ECR and deploys to ECS"
        default: true
        required: false
        type: boolean
      push_to_ecr:
        description: "If true, pushes to ECR only"
        default: false
        required: false
        type: boolean
      secrets_ssm_path:
        description: "SSM path to parameters that need to be injected into secrets arrays in task definition"
        required: false
        type: string
      chamber_ssm_path:
        description: "SSM path to parameters that need to be injected into application .env file for build"
        required: false
        type: string
      chamber_dot_env_path:
        description: "Path to dot env to be generated by chamber (required if chamber_ssm_path is provided)"
        default: .env
        required: false
        type: string
      anvil:
        description: "Does build pull from ECR anvil"
        default: true
        required: false
        type: boolean
      task_definition:
        description: "Path to task definition if you are not using a template"
        required: false
        type: string
      get_parameters:
        description: "A GitHub action for AWS Systems Manager Parameter Store GetParameters call and placing the results into environment variables"
        required: false
        type: string
      slack_channel:
        description: "Slack channel to send Wiz notifications on merge"
        required: false
        type: string
      wiz_scan_fail:
        description: "Fail the Wiz scan if there are vulnerabilities"
        default: true
        required: false
        type: boolean
      docker_build_ssh:
        description: "Enable docker build --ssh"
        default: false
        required: false
        type: boolean
      platform_architecture:
        description: Linux Platform ex. amd64, arm64
        default: amd64
        required: false
        type: string
      removetoolcache:
        description: "Delete the tools cache folder"
        default: false
        required: false
        type: string
  

    secrets:
      RV_LONELYPLANET_SVC_PRIVATE_SSH_KEY:
        required: false
      WIZCLI_ID:
        required: true
      WIZCLI_SECRET:
        required: true
      SLACK_WEBHOOK:
        required: false

# Concurrency ensures that a workflow using the same concurrency group will run at a time.
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref_name }}
  cancel-in-progress: true


env:
  DOCKER_BUILDKIT: 1
  GIT_SHA: ${{ github.sha }}
  ENVIRONMENT: ${{ inputs.environment }}
  AWS_ACCOUNT: ${{ inputs.aws_account }}
  AWS_REGION: ${{ inputs.aws_region }}
  TASK_DEFINITION: ${{ inputs.task_definition }}
  IMAGE_CACHE_DIR: /tmp/.buildx-cache
  CACHE_KEY: buildx-${{ github.sha }}-${{ inputs.ENVIRONMENT }}-${{ github.run_number }}

jobs:
  build:
    name: Build & test
    runs-on: ubuntu-latest
    outputs: 
      image: ${{ steps.build.outputs.image }}
      repo: ${{ steps.set-repo.outputs.repo }}
      service: ${{ steps.set-service.outputs.service }}
    permissions:
      id-token: write
      contents: read
    steps:
      - name: Delete huge unnecessary tools folder
        if: ${{ inputs.removetoolcache }}
        run: rm -rf /opt/hostedtoolcache 
      
      - name: Checkout
        uses: actions/checkout@v3

      - name: Pass secret to use in conditional
        id: pass-ssh
        run: |
          echo "ssh_key<<EOF" >> $GITHUB_OUTPUT
          echo "${{ secrets.RV_LONELYPLANET_SVC_PRIVATE_SSH_KEY }}" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Install SSH keys
        if: ${{ steps.pass-ssh.outputs.ssh_key != '' }}
        uses: shimataro/ssh-key-action@v2
        with:
          key: ${{ secrets.RV_LONELYPLANET_SVC_PRIVATE_SSH_KEY }}
          known_hosts: github.com

      - name: Setup Ruby and install dependencies
        if: ${{ inputs.install_ruby }}
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true # runs 'bundle install' and caches installed gems automatically
      
      - name: Install Node
        if: inputs.install_node
        uses: actions/setup-node@v2
        with:
          node-version: ${{ inputs.node_version }}

      - name: Remove owner from repo name
        id: set-repo
        run: |
          repo=${{ github.repository }}
          echo "repo=$(echo "/"${repo#*"/"} | sed 's|/||')" >> $GITHUB_OUTPUT

      - name: Replace service name with new repo name if service name not provided
        id: set-service
        run: |
          if [[ ${{ github.repository }} == ${{ inputs.service }} ]]; then
            echo "service=${{ steps.set-repo.outputs.repo }}" >> $GITHUB_OUTPUT
          else
            echo "service=${{ inputs.service }}" >> $GITHUB_OUTPUT
          fi

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: "arn:aws:iam::${{ inputs.aws_account }}:role/gha-${{ steps.set-repo.outputs.repo }}"
          aws-region: ${{ inputs.aws_region }}

      # In case that AWS Parameter Store use different GHA KEYs
      # Backed up GHA AWS KEYS before compile the assets  
      - name: "Backup AWS KEYs"
        shell: bash
        if: ${{ inputs.aws_parameters }}
        run: |
            echo "BKP_AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID" >> $GITHUB_ENV
            echo "BKP_AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY" >> $GITHUB_ENV
   
      - name: "Build parameterPairs of SSM Get Parameters"
        shell: bash
        if: ${{ inputs.aws_parameters }}
        run: |
            echo "AWS_PARAMETERS=$(echo ${{ inputs.aws_parameters }} | sed 's|[^,]*|\/${{ inputs.service }}\-${{ env.ENVIRONMENT }}\/& = &|g')"  >> $GITHUB_ENV
 
      - name: "SSM Get Parameters Placing into Env Variables"
        if: ${{ inputs.aws_parameters }}
        uses: dkershner6/aws-ssm-getparameters-action@v1
        with:
          parameterPairs: ${{ env.AWS_PARAMETERS }}
      
      - name: Assets Precompile
        if: ${{ inputs.install_ruby }}
        run: |
            bundle exec rake assets:clean
            bundle exec rake assets:precompile

      # In case that AWS Parameter Store use different GHA KEYs
      # Restore original GHA AWS KEYS after compile the assets  
      - name: Restore AWS keys
        shell: bash
        if: ${{ inputs.aws_parameters }}
        run: |
            echo "AWS_ACCESS_KEY_ID=$BKP_AWS_ACCESS_KEY_ID" >> $GITHUB_ENV
            echo "AWS_SECRET_ACCESS_KEY=$BKP_AWS_SECRET_ACCESS_KEY" >> $GITHUB_ENV

      - name: Login to Anvil ECR (container image pipeline images)
        if: ${{ inputs.anvil }}
        uses: aws-actions/amazon-ecr-login@v1
        with:
          registries: '089022728777'

      - name: Install chamber & generate dot env
        if: ${{ inputs.chamber_ssm_path != '' }}
        run: |
          wget https://github.com/segmentio/chamber/releases/download/v2.10.1/chamber-v2.10.1-linux-amd64 -O ./chamber  && \
          chmod +x ./chamber && \
          sudo mv chamber /usr/local/bin
          chamber export --format dotenv "${{ inputs.chamber_ssm_path }}" |tr -d '"' >> ${{ inputs.chamber_dot_env_path }}

      # This is the a separate action that sets up buildx runner
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          install: true

      # So now you can use Actions own caching
      - name: Cache Docker layers
        uses: actions/cache@v3
        with:
          path: ${{ env.IMAGE_CACHE_DIR }}
          key: ${{ env.CACHE_KEY }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      - name: Set build args
        if: ${{ inputs.build_args != '' }}
        run: |
          IFS=','
          read -a strarr <<< "${{ inputs.build_args }}"
          args=''
          for arg in "${strarr[@]}";
          do
            args="${args} --build-arg $arg"
          done
          echo "BUILD_ARGS=$args" >> $GITHUB_ENV
      
      - name: Set build ssh
        if: ${{ inputs.docker_build_ssh }}
        run: |
          echo "SSH_DEFAULT=--ssh default" >> $GITHUB_ENV
      
      # https://joel-azemar.medium.com/ci-share-docker-image-across-jobs-with-github-actions-b0d6f7a4e205
      - name: Build docker image
        id: build
        run:  |
          if [[ ${{ inputs.docker_build_ssh }} = true ]]; then
            eval $(ssh-agent)
            ssh-add ~/.ssh/id_rsa
          fi
          docker build --platform=linux/${{ inputs.platform_architecture }} -t ${{ steps.set-service.outputs.service }}-${{ env.ENVIRONMENT }} ${{ env.BUILD_ARGS }} ${{ env.SSH_DEFAULT }} . -f ${{ inputs.dockerfile_path }} --cache-from type=local,src=${{ env.IMAGE_CACHE_DIR }},mode=max --cache-to type=local,dest=${{ env.IMAGE_CACHE_DIR }}-new --load --allow security.insecure
          echo "image=${{ steps.set-service.outputs.service }}-${{ env.ENVIRONMENT }}" >> $GITHUB_OUTPUT

      - name: Test image
        if: ${{ inputs.test_command != '' }}
        run: ${{ inputs.test_command }}

      # This ugly bit is necessary if you don't want your cache to grow forever
        # till it hits GitHub's limit of 5GB.
      - name: Move cache
        run: |
          rm -rf ${{ env.IMAGE_CACHE_DIR }}
          mv ${{ env.IMAGE_CACHE_DIR }}-new ${{ env.IMAGE_CACHE_DIR }}

      - name: Save Docker image as tar file
        run: |
          docker save -o ${{ env.IMAGE_CACHE_DIR }}/${{ steps.build.outputs.image }}.tar ${{ steps.build.outputs.image }}
          cd ${{ env.IMAGE_CACHE_DIR }}
          ls -latr

      
  wiz-scan:
    name: Wiz scan
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Declare Cache Registry
        uses: actions/cache@v3
        with:
          path: ${{ env.IMAGE_CACHE_DIR }}
          key: ${{ env.CACHE_KEY }}
      - name: Docker load
        run: |
          cd ${{ env.IMAGE_CACHE_DIR }}
          ls -latr
          docker load --input ${{ env.IMAGE_CACHE_DIR }}/${{ needs.build.outputs.image }}.tar
          docker images
      - name: Wiz scan and Slack notification
        uses: lonelyplanet/actions/.github/actions/wiz-scan-notify@main
        with:
          image: ${{needs.build.outputs.image}}
          slack_notify: ${{ inputs.deploy }} # Run only when image is being deployed to ECS
          slack_channel: ${{ inputs.slack_channel }}
          wiz_scan_fail: ${{ inputs.wiz_scan_fail }}
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          WIZCLI_ID: ${{ secrets.WIZCLI_ID }}
          WIZCLI_SECRET: ${{ secrets.WIZCLI_SECRET }}


  push:
    name: Push image
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    needs: [build]
    if: ${{ inputs.deploy }} || ${{ inputs.push_to_ecr }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Declare Cache Registry
        uses: actions/cache@v3
        with:
          path: ${{ env.IMAGE_CACHE_DIR }}
          key: ${{ env.CACHE_KEY }}
      - name: Docker load
        run: |
          cd ${{ env.IMAGE_CACHE_DIR }}
          ls -latr
          docker load --input ${{ env.IMAGE_CACHE_DIR }}/${{ needs.build.outputs.image }}.tar
          docker images
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: "arn:aws:iam::${{ inputs.aws_account }}:role/gha-${{needs.build.outputs.repo}}"
          aws-region: ${{ inputs.aws_region }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      - name: Tag and push image
        run: |
          docker tag ${{needs.build.outputs.image}} ${{ steps.login-ecr.outputs.registry }}/${{needs.build.outputs.service}}-${{ env.ENVIRONMENT }}:${{ github.sha }}
          docker tag ${{needs.build.outputs.image}} ${{ steps.login-ecr.outputs.registry }}/${{needs.build.outputs.service}}-${{ env.ENVIRONMENT }}:latest
          docker push ${{ steps.login-ecr.outputs.registry }}/${{needs.build.outputs.service}}-${{ env.ENVIRONMENT }}:${{ github.sha }}
          docker push ${{ steps.login-ecr.outputs.registry }}/${{needs.build.outputs.service}}-${{ env.ENVIRONMENT }}:latest

  deploy:
    name: Deploy to ECS
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read
    needs: [build, push]
    if: ${{ inputs.deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          role-to-assume: "arn:aws:iam::${{ inputs.aws_account }}:role/gha-${{needs.build.outputs.repo}}"
          aws-region: ${{ inputs.aws_region }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v1
      - name: Set env vars from .task.env
        if: ${{ env.TASK_DEFINITION == '' }}
        run: |
          docker run -v `pwd`/.task.env:/app/.task.env --workdir /app --rm python:alpine3.15 python -c "lines = list(map(lambda x:x.strip(), open('.task.env', 'r').readlines() + ['']))
          sub_arr = lines[lines.index(\"${{ env.ENVIRONMENT }}\" + ':') + 1:]
          print(''.join(x + '\n' for x in sub_arr[:[indx for indx, i in enumerate(sub_arr) if ':' in i or i == ''][0]]))" | while read line
          do
            if [[ "$line" != *"#"* ]]; then
              echo "$line" >> $GITHUB_ENV
            fi
          done

      - name: Fill in Task Definition template
        if: ${{ env.TASK_DEFINITION == '' }}
        run: |
          sudo apt-get install gettext=0.21-4ubuntu4 -y
          cat .github/workflows/task-definition.json | envsubst > tmp.json && mv tmp.json .github/workflows/task-definition.json

      - name: Inject Secrets into task def
        if: ${{ inputs.secrets_ssm_path != '' }}
        run: |
          aws ssm get-parameters-by-path --path ${{ inputs.secrets_ssm_path }} --region ${{ env.AWS_REGION }} --recursive | jq -r '.Parameters[] .ARN' > secrets;
          docker run -v `pwd`/secrets:/app/secrets -v `pwd`/.github/workflows/task-definition.json:/app/task-definition.json --workdir /app --rm python:alpine3.15 python -c "
          import json
          import os
          secrets_file = open('secrets')
          secrets = secrets_file.readlines()
          filename = 'task-definition.json'
          with open(filename, 'r') as f:
            data = json.load(f)
          for container in data['containerDefinitions']:
            for secret in secrets:
              container['secrets'].append({'name': secret[secret.rindex('/') + 1:].strip(), 'valueFrom': secret.strip()})
          with open(filename, 'w') as f:
            json.dump(data, f, indent=4)"
          rm secrets

      - name: Get cluster name
        id: get-cluster
        run: |
          res=$(aws ecs list-clusters | jq -r '.clusterArns[]')
          len=$(aws ecs list-clusters | jq '[.clusterArns[]] | length')
          if [[ $len -eq 1 ]]; then
            echo "cluster=$(echo "/"${res#*"/"} | sed 's|/||')" >> $GITHUB_OUTPUT
          elif [[ "${{ inputs.cluster != '' }}" == "true" ]]; then
            echo "cluster=${{ inputs.cluster }}" >> $GITHUB_OUTPUT
          else
            echo "Cluster input is necessary when there is not only one ECS cluster in the given AWS account"
            exit 1
          fi

      - name: Deploy Amazon ECS (no template)
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        if: ${{ env.TASK_DEFINITION != '' }}
        with:
          task-definition: ${{ env.TASK_DEFINITION }}
          service: ${{needs.build.outputs.service}}-${{ env.ENVIRONMENT }}
          cluster: ${{ steps.get-cluster.outputs.cluster }}
          wait-for-service-stability: false

      - name: Deploy Amazon ECS (template)
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        if: ${{ env.TASK_DEFINITION == '' }}
        with:
          task-definition: .github/workflows/task-definition.json
          service: ${{needs.build.outputs.service}}-${{ env.ENVIRONMENT }}
          cluster: ${{ steps.get-cluster.outputs.cluster }}
          wait-for-service-stability: false

      - name: Setup tmate session
        uses: mxschmitt/action-tmate@v3
        if: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.debug_enabled == 'true' }}
        timeout-minutes: 30
        continue-on-error: true
